package goleveldb

// #cgo LDFLAGS: -lleveldb
// #include "leveldb/c.h"
import "C"

type CompressionType int

// DB contents are stored in a set of blocks, each of which holds a
// sequence of key,value pairs.  Each block may be compressed before
// being stored in a file.  The following describes which
// compression method (if any) is used to compress a block.
const (
	// NOTE: do not change the values of existing entries, as these are
	// part of the persistent format on disk.
	NoCompression     CompressionType = 0x0
	SnappyCompression CompressionType = 0x1
)

// Options to control the behavior of a database (passed to goleveldb.Open).
//  NOTE: Options should be created with NewOptions.
//
// To prevent memory leaks, Destroy must be called on an Options when the
// program no longer needs it.
type Options struct {
	opt *C.leveldb_options_t
}

// NewOptions allocates a new Options object.
func NewOptions() *Options {
	return &Options{C.leveldb_options_create()}
}

// Destroy deallocates the Options, freeing its underlying C struct.
func (o *Options) Destroy() {
	C.leveldb_options_destroy(o.opt)
	o.opt = nil
}

// Comparator used to define the order of keys in the table.
// If non-nil, use the specified comparator.
//
//  Default: a comparator that uses lexicographic byte-wise ordering
//
// REQUIRES: The client must ensure that the comparator supplied
// here has the same name and orders keys *exactly* the same as the
// comparator provided to previous open calls on the same DB.
func (o *Options) SetComparator(cmp *C.leveldb_comparator_t) {
	if cmp != nil {
		C.leveldb_options_set_comparator(o.opt, cmp)
	}
}

// Use the specified filter policy to reduce disk reads.
//  NOTE: you must call either SetFilterPolicy or SetBloomFilterPolicy,
//  there is one of them applied at any time.
//
//  Default: nil
func (o *Options) SetFilterPolicy(fp *C.leveldb_filterpolicy_t) {
	C.leveldb_options_set_filter_policy(o.opt, fp)
}

// Use the specified filter policy to reduce disk reads.
//  NOTE: you must call either SetFilterPolicy or SetBloomFilterPolicy,
//  there is one of them applied at any time.
//
//  Default: nil
func (o *Options) SetBloomFilterPolicy(fp *FilterPolicy) {
	if fp == nil {
		C.leveldb_options_set_filter_policy(o.opt, nil)
	} else {
		C.leveldb_options_set_filter_policy(o.opt, fp.fp)
	}
}

// If not non-nil, use the specified object to interact with the environment,
// e.g. to read/write files, schedule background work, etc.
//
//  Default: C.leveldb_create_default_env()
func (o *Options) SetEnv(env *C.leveldb_env_t) {
	if env != nil {
		C.leveldb_options_set_env(o.opt, env)
	}
}

// If true, the database will be created if it is missing.
//
//  Default: false
func (o *Options) SetCreateIfMissing(b bool) {
	C.leveldb_options_set_create_if_missing(o.opt, bool2uchar(b))
}

// If true, an error is raised if the database already exists.
//
//  Default: false
func (o *Options) SetErrorIfExists(b bool) {
	C.leveldb_options_set_error_if_exists(o.opt, bool2uchar(b))
}

// If true, the implementation will do aggressive checking of the
// data it is processing and will stop early if it detects any
// errors.  This may have unforeseen ramifications: for example, a
// corruption of one DB entry may cause a large number of entries to
// become unreadable or for the entire DB to become unopenable.
//
//  Default: false
func (o *Options) SetParanoidChecks(b bool) {
	C.leveldb_options_set_paranoid_checks(o.opt, bool2uchar(b))
}

// Any internal progress/error information generated by the db will
// be written to info_log if it is non-nil, or to a file stored
// in the same directory as the DB contents if info_log is nil.
//
//  Default: nil
func (o *Options) SetInfoLog(log *C.leveldb_logger_t) {
	C.leveldb_options_set_info_log(o.opt, log)
}

// Amount of data to build up in memory (backed by an unsorted log
// on disk) before converting to a sorted on-disk file.
//
// Larger values increase performance, especially during bulk loads.
// Up to two write buffers may be held in memory at the same time,
// so you may wish to adjust this parameter to control memory usage.
// Also, a larger write buffer will result in a longer recovery time
// the next time the database is opened.
//
//  Default: 4MB
func (o *Options) SetWriteBufferSize(size int) {
	C.leveldb_options_set_write_buffer_size(o.opt, C.size_t(size))
}

// Number of open files that can be used by the DB.  You may need to
// increase this if your database has a large working set (budget
// one open file per 2MB of working set).
//
//  Default: 1000
func (o *Options) SetMaxOpenFiles(n int) {
	C.leveldb_options_set_max_open_files(o.opt, C.int(n))
}

// If non-nil, use the specified cache for blocks.
//
//  Default: leveldb will automatically create and use an 8MB internal cache.
func (o *Options) SetCache(cache *Cache) {
	if cache != nil {
		C.leveldb_options_set_cache(o.opt, cache.cache)
	}
}

// Approximate size of user data packed per block.  Note that the
// block size specified here corresponds to uncompressed data.  The
// actual size of the unit read from disk may be smaller if
// compression is enabled.  This parameter can be changed dynamically.
//
//  Default: 4K
func (o *Options) SetBlockSize(size int) {
	C.leveldb_options_set_block_size(o.opt, C.size_t(size))
}

// Number of keys between restart points for delta encoding of keys.
// This parameter can be changed dynamically.  Most clients should
// leave this parameter alone.
//
//  Default: 16
func (o *Options) SetBlockRestartInterval(n int) {
	C.leveldb_options_set_block_restart_interval(o.opt, C.int(n))
}

// Compress blocks using the specified compression algorithm.  This
// parameter can be changed dynamically.
//
//  Default: SnappyCompression, which gives lightweight but fast
//  compression.
//
// Typical speeds of SnappyCompression on an Intel(R) Core(TM)2 2.4GHz:
//   ~200-500MB/s compression
//   ~400-800MB/s decompression
// Note that these speeds are significantly faster than most
// persistent storage speeds, and therefore it is typically never
// worth switching to SnappyCompression.  Even if the input data is
// incompressible, the SnappyCompression implementation will
// efficiently detect that and will switch to uncompressed mode.
func (o *Options) SetCompression(t CompressionType) {
	C.leveldb_options_set_compression(o.opt, C.int(t))
}
